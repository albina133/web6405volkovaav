<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/styles/style.css">
    <title>Метод "туда-обратно"</title>
</head>

<body>
    
    <div class="nav">
        <a href="index.html">О программе</a>
        <a href="prog_realization.html">Программная реализация</a>
        <a class="active" href="method.html">Метод "туда-обратно"</a>
        <a href="results.html">Результаты</a>
    </div>

    <div class="info">
        <h2>Описание метода «туда-обратно»</h2>
        <p class="text">
            &emsp;Начнем с того, что базу кода составляют точки, по которым и строится область.
            Они устанавливаются на левую кнопку мыши и сохраняются в векторе points.
            Также эти точки можно динамически передвигать по всей области приложения. <br>
            &emsp;Далее необходимо было расставить отметки между точками области.
            Для этого были написаны функции findBoundaryPoints и PlacementWaypoints.
            Функция findBoundaryPoints определяет самую крайнюю левую, правую, верхнюю и нижнюю точки и заносит данные в вектор.
            Уже он используется в функции PlacementWaypoints для того, чтобы построить прямоугольник, внутри которого будет находиться наша область.
            Найдя ширину и высоту прямоугольника, вычисляется интервал для размещения точек и их количество.
            Важным уточнением является то, что количество точек можно указать самостоятельно, и, чем больше их расставлено по всей области, тем большую траекторию объект сможет пройти. <br>
            &emsp;Далее по прямоугольнику расставляются путевые точки.
            Но для оптимизации метода «туда-обратно» нам необходимо расположить их на области, поэтому используется новая функция EquationLinesFound.
            Она наглядно отрисовывает отрезки между соседними точками по нахождению уравнений прямых и добавляет в вектор пару соседних точек.
            За основу расчета уравнений прямых была взята формула: <br>
        </p>
        <center>
            <p class="text">(x - x<sub>1</sub>) / (x<sub>2</sub> - x<sub>1</sub>) = (y - y<sub>1</sub>) / (y<sub>2</sub> - y<sub>1</sub>)</p>
        </center>
        <p class="text">
            где x<sub>1</sub> и y<sub>1</sub> – координаты первой точки,<br>
            x<sub>2</sub> и y<sub>2</sub> – координаты второй точки.
        </p>
        <p class="text">
            &emsp;Наконец, для каждой отметки на прямоугольнике высчитывается ее расстояние до области по координате y.
            А после, в зависимости от того, нижняя это отметка или верхняя, прибавляется или убавляется рассчитанное расстояние от координаты y. <br>
            Подготовив все данные, перейдем к методу «туда-обратно».
            В этом методе поиск осуществляется путем параллельного перемещения вперед и назад, поворота возврата назад.
            Его работа довольно проста: <br>
            <ol class="list">
                <li>Находим самую левую нижнюю отметку на области.</li>
                <li>Двигаемся вверх.</li>
                <li>Переходим к точке, стоящей справа.</li>
                <li>Повторяем шаги 1, 2 и 3 до последней отметки.</li>
            </ol>
        </p>
        <p class="text">
            &emsp;Так как в векторе waypoints верхние отметки хранятся под четными индексами, а нижние – под нечетными, то отрисовка линий происходила по принципу разбивки линий на вертикальные и горизонтальные с полным учетом индексов.
            Как итог, мы получаем реализованный метод «туда-обратно», показанный на рисунке 2.
        </p>
        <center>
            <img src="static/pictures/realization_method.png" alt="Пример реализации метода «туда-обратно»">
            <p id="text_for_img">Рисунок 2 – Пример реализации метода «туда-обратно»</p>
        </center>
        <p class="text">
            &emsp;Если интересно более подробное описание метода «туда-обратно», то можно перейти по ссылке указанной ниже.
        </p>
        <div>
            <center>
                <a id="ref" href="https://www.mdpi.com/2504-446X/3/1/4">
                    Название: Survey on Coverage Path Planning with Unmanned Aerial Vehicles <br>
                    Авторы: T.M. Cabreira, L.B. Brisolara, F.J. Paulo R.
                </a>
            </center>
        </div>
        <p class="text">
            &emsp;Также ниже, в таблице 1, можно посмотреть другие, которые используются в статье, которые можно применить к задаче построения маршрута при обходе бесполетных зон.
        </p>
        <p class="text">Таблица 1 - Описание различных методов для обхода препятствий</p>
        <table>
            <thead>
                <tr>
                    <th>Название метода</th>
                    <th class="center">Краткое описание</th>
                    <th class="right">Особенности</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Единые стратегии</td>
                    <td class="center">Использование фиксированных стратегий для всех клеток.</td>
                    <td class="right">Простота реализации, но может не учитывать локальные условия и особенности каждой клетки.</td>
                </tr>
                <tr>
                    <td>Стратегии сотрудничества</td>
                    <td class="center">Клетки работают совместно, обмениваясь информацией и ресурсами.</td>
                    <td class="right">Улучшает общую эффективность, но требует сложной координации и коммуникации между клетками.</td>
                </tr>
                <tr>
                    <td>Туда-обратно</td>
                    <td class="center">Движение в одном направлении с последующим возвращением для оптимизации.</td>
                    <td class="right">Позволяет учитывать изменения в окружающей среде, но может быть менее эффективным по времени.</td>
                </tr>
                <tr>
                    <td>Спираль</td>
                    <td class="center">Движение по спирали вокруг центра или исходной точки.</td>
                    <td class="right">Эффективно для охвата области, но может быть неэффективным для больших пространств.</td>
                </tr>
                <tr>
                    <td>Формирование линии</td>
                    <td class="center">Клетки организуются в линию для выполнения задачи.</td>
                    <td class="right">Удобно для линейных задач, но ограничивает гибкость в изменении конфигурации.</td>
                </tr>
                <tr>
                    <td>Децентрализованный метод</td>
                    <td class="center">Каждая клетка принимает решения независимо, основываясь на локальной информации.</td>
                    <td class="right">Высокая устойчивость к сбоям, но может привести к неоптимальным решениям из-за недостатка глобальной информации.</td>
                </tr>
                <tr>
                    <td>Местный приоритет</td>
                    <td class="center">Определение приоритетов на основе локальных условий и потребностей.</td>
                    <td class="right">Позволяет адаптироваться к изменениям в окружении, но может игнорировать более широкие цели.</td>
                </tr>
            </tbody>
        </table>    
    </div>

</body>

</html>